- [x] Go through the code and apply the rules around constants from the instructions
- [x] Go through the code and check for types that can be made more descriptive. Either by creating a new class, or just us a type alias. For example things like `Map<GrainPoint, number>`. What does `number` represent there? If a non-bespoke type is used, make sure to document what it represents in a doc comment. For example is a `number` that represents a color in srgb or linear?
- [x] Add section about using descriptive types or aliases where it makes sense to your instructions.
- [x] Add a code formatting configuration to the project. And apply it to all source code.
- [x] Go through the code and make sure we are using idiomatic modern typescript. For example use \*\* instead of Math.pow. Update your instructions to make sure you use modern idiomatic typescript in the future. Also add eslint checks where applicable. Start by running a test to make sure your changes does not add new ones. Keep going until the tests and `npm run check` passes.
  - [x] Replace all instances of `Math.pow(a, b)` with `a ** b`.
  - [x] Research and apply other modern idiomatic TypeScript features where applicable.
  - [x] Update GEMINI.md to instruct the use of modern idiomatic TypeScript, including the `**` operator.
  - [x] Run tests and `npm run check` to ensure all changes are safe.
- [x] Apply the rules from "Static Methods and Free Functions" from your instructions to grain-processor.ts
- [x] Write testcases for GrainProcessor.adjustGrainExposures
- [x] Write unit tests for calculateLightnessFactor
- [x] Write test that ensures that the lightness iteration converges. Specifically that the individual components behave.
 - [x] Make sure the value returned by calculateLightnessFactor behaves correctly when applied by adjustGrainExposures
- [x] Apply the instructions from the "Descriptive Types and Type Aliases" section on the types in types.ts
- [x] Implement sampling estimation for the iterative lightness compensation in processImage.
  - [x] Extract core pixel processing logic from `processPixelEffects` into a reusable function
  - [x] Create a sampling-based estimation function that processes a subset of pixels
  - [x] Implement grid-based or random sampling strategy for representative pixel selection
  - [x] Replace the full `processPixelEffects` call in the iteration loop with the sampling estimation
  - [x] Add configuration options for sampling density/strategy
  - [x] Profile to make sure it improves performance
  - [x] Add tests to ensure sampling estimation provides reasonable accuracy vs full processing
- [x] Clean up comments like ```// See ALGORITHM_DESIGN.md: "Darkroom Printing Phase"``` that are no longer valid with the updated ALGORITHM_DESIGN.md
- [x] disable the test "should produce LARGER average grain sizes as ISO increases" and move "should provide significant performance improvement over full processing" to benchmarking
- [x] Refactor GrainProcessor to allow us to specify the exact grains to use for processImage. Write a test that generates uniform grains on a dense grid and use those along with a middle gray test image for processImage. Test that the output is mostly uniform gray without much structure.
- [x] Change the grain debug drawing to show the size of the grains using color.
- [x] Do we have a test that checks the density of points generated using poisson disk sampling vs fallback? If not create one. The densities should be mostly the same.
- [x] Write a test of processImage supplying customGrains as an empty array. The output image should be completely black.
- [ ] Keep track of the largest grain in SpatialLookupGrid and use that radius in getGrainsNear instead of specifying a custom one. Also make sure getGrainsNear with that radius would be sure to pick up all grains that could affect the requested position.
- [ ] Is GRAIN_LOOKUP_RADIUS too small? is it incorrectly calculated? shouldn't it be based on the size of the largest grain? and why is it in all caps anyway?
- [x] Examine why the algorithm introduces striped patterns. Look at gray.png grain-processed-image.png
- [ ] write an eslint rule to disallow raw Math.random  instead RandomNumberGenerator should be dependency injected. The only allowed Math.random is in DefaultRandomNumberGenerator, and in test code.
- [ ] Write test of processImage with a testpattern with the left side fully white and the right side fully black. Use a low iso. The output image should be almost completely white on the left side and almost completely black on the right side
- [ ] Reenable these tests and make sure they pass
  - [ ] Reenable `test/grain-processor-integration.test.ts` > "should process gradient patterns correctly" and investigate why it outputs black.
  - [ ] Reenable `test/grain-processor-integration.test.ts` > "should process radial patterns correctly" and investigate why it outputs black.
  - [ ] Reenable `test/grain-processor-integration.test.ts` > "should produce different results for different film types" and investigate why it outputs black.
  - [ ] Reenable `test/iterative-vs-single-pass.test.ts` > "should demonstrate improved lightness preservation with iterative approach" and investigate why it outputs black.
  - [ ] Reenable `test/grain-physical-behavior.test.ts` > "should produce FEWER grains as ISO increases" and update the test to work with a smaller image to make it faster.
- [ ] Remove any constants from constants.ts that are not used anywhere or are only used in tests
- [ ] Move any constant in constants.ts that are only used a single place to that place and remove it from constants.ts
- [ ] Enable each test below one by one. Check if it passes. If not, determine if the code or the test is wrong (probably the test). If the test is wrong, determine if it is worth it to update the test or better to just remove it.
  - [ ] `test/grain-processor.test.ts` > "should produce minimal changes to the original image at low ISO"
  - [ ] `test/grain-processor.test.ts` > "should have minimal grain effect at very low ISO (50)"
  - [ ] `test/grain-processor.test.ts` > "should preserve image structure at low ISO"
  - [ ] `test/grain-processor-integration.test.ts` > "should process checkerboard patterns correctly"
  - [ ] `test/grain-processor-integration.test.ts` > "should process gradient patterns correctly"
  - [ ] `test/grain-processor-integration.test.ts` > "should process radial patterns correctly"
  - [ ] `test/grain-processor-integration.test.ts` > "should maintain reasonable processing times"
  - [ ] `test/grain-processor-integration.test.ts` > "should produce minimal changes to the original image at low ISO"
  - [ ] `test/grain-processor-integration.test.ts` > "should have minimal grain effect at very low ISO (50)"
  - [ ] `test/grain-processor-integration.test.ts` > "should preserve image structure at low ISO"
  - [ ] `test/grain-processor-integration.test.ts` > "should produce different results for different film types"
  - [ ] `test/grain-physical-behavior.test.ts` > "should produce FEWER grains as ISO increases"
  - [ ] `test/exposure-lightness-preservation.test.ts` > "should preserve overall lightness for middle gray (18% gray)"
  - [ ] `test/exposure-lightness-preservation.test.ts` > "should preserve overall lightness for various gray levels"
  - [ ] `test/exposure-lightness-preservation.test.ts` > "should preserve overall lightness for black and white extremes"
  - [ ] `test/iterative-vs-single-pass.test.ts` > "should demonstrate improved lightness preservation with iterative approach"
  - [ ] `test/grain-two-phase-verification.test.ts` > "Performance Characteristics" (describe.skip)
- [ ] Create a page like public/grain-debug.html that replicates the testpatterns from grain-processor-integration.test.ts
- [ ] Update the grain generation logic to do a full 3d emulsion simulation.
  - In real film grains are suspended at multiple depths, and can overlap.
  - In the current implementation we don't support overlapping.
  - Could just take the current grain generation and just have multiple at different depths?
  - refer to GRAIN_OVERLAPPING.md for some notes on the issue
  - Update ALGORITHM_DESIGN.md with the new functionality
- [ ] Refactor functions like processPixelEffects to instead of iterating over pixels and using the spatial lookup grid it should iterate over grains and "render" those to the output image. Make sure it actually improves performance
- [ ] Add support for lower iso than 50
- [ ] Make sure the tests in grain-processor-integration.test.ts are not too lenient
- [ ] Add slider to control how large the grains are relative to the image, as if to simulate the image being a cropped version of a small sections of the negative. (Or will this have the same effect as adjusting the iso?)
- [ ] Do the film type settings refer to common industry standard settings? Or do they just result in some made up parameters? If made up, convert them to use some non-brand names instead. Or expose the underlying parameters?
- [ ] In the gui make the unprocessed image also show as grayscale. Apply the same rgb to grayscale operation as in the grain processing pipeline.
- [ ] Enable all skipped tests again. If they fail check if they are outdated and should be removed. If they are still applicable determine if the code or the test is wrong.
- [ ] Go through the testcases and make sure they are all enabled and makes sense
- [ ] Optimize the algorithm
- [ ] Clean up unused files and debug utils such as `public/grain-test.html`
- [ ] Clean up old agent-generated analysis and summary md files.
- [ ] Update dependencies.
- [ ] **Implement grain bridging and clustering effects**: Add simulation of grains connecting during development through clustering algorithms. This creates more realistic grain patterns that match actual film behavior.
- [ ] **Add edge effects near high-contrast boundaries**: Implement grain density changes near high-contrast image boundaries to simulate developer depletion and chemical diffusion effects.
- [ ] Is it possible to parallelize the algorithm? Or move parts of it to the gpu using webgpu?
- [ ] Look for TODO comments in the code, and list them as subitems here.
- [ ] Go through the repo and clean up any unused files
- [ ] Go through the code looking for repeating patterns and refactor them into shared code if it makes sense.
- [ ] The html files in public shouldn't be included in the production build
- [ ] Go through the code and clean up any comments left by a coding agent to indicate what it has changed. Comments should typically describe "why" not "what. And while comments describing changes is useful when iteracting with an agent we don't want that in the final code.

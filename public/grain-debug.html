<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grain Algorithm Debug Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .dev-only {
            border: 2px solid #ff6b35;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #2a1a1a;
            border-radius: 8px;
        }
        
        .dev-only h2 {
            color: #ff6b35;
            margin-top: 0;
        }
        
        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #2a2a2a;
            border-radius: 5px;
        }
        
        .controls label {
            display: inline-block;
            width: 140px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .controls input, .controls select {
            margin: 5px 10px 5px 0;
            padding: 4px 8px;
            background-color: #3a3a3a;
            color: #ffffff;
            border: 1px solid #555;
            border-radius: 3px;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .visualization-panel {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #444;
        }
        
        .visualization-panel h3 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }
        
        canvas {
            border: 1px solid #555;
            background-color: #000;
            margin: 10px 0;
            display: block;
            max-width: 100%;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        
        .layer-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .layer-button {
            background-color: #666;
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .layer-button.active {
            background-color: #4CAF50;
        }
        
        .stats {
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .color-legend {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .color-box {
            width: 12px;
            height: 12px;
            border: 1px solid #666;
        }
        
        .warning {
            background-color: #ff4444;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="dev-only">
        <h2>üîß Development Debug Page</h2>
        <p>This page visualizes internal components of the grain algorithm and is only available in development mode.</p>
    </div>

    <h1>Grain Algorithm Debug Visualizer</h1>
    
    <div class="controls">
        <div>
            <label>Canvas Width:</label>
            <input type="number" id="width" value="400" min="100" max="800">
            
            <label>Canvas Height:</label>
            <input type="number" id="height" value="300" min="100" max="600">
            
            <label>ISO:</label>
            <input type="number" id="iso" value="400" min="100" max="3200">
        </div>
        <div>
            <label>Film Type:</label>
            <select id="filmType">
                <option value="kodak">Kodak</option>
                <option value="fuji">Fuji</option>
                <option value="ilford">Ilford</option>
            </select>
            
            <label>Grain Intensity:</label>
            <input type="range" id="grainIntensity" min="0" max="2" step="0.1" value="1.0">
            <span id="intensityValue">1.0</span>
        </div>
        <div>
            <button onclick="generateDebugVisualization()">Generate Visualization</button>
            <button onclick="testGrainDensity()">Test Density Calculation</button>
            <button onclick="clearAllCanvases()">Clear All</button>
        </div>
    </div>

    <div class="visualization-grid">
        <!-- Raw Grain Points -->
        <div class="visualization-panel">
            <h3>Raw Grain Points</h3>
            <canvas id="rawGrainsCanvas" width="400" height="300"></canvas>
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background-color: #00ff00;"></div>
                    <span>Poisson Points</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ff6666;"></div>
                    <span>Fallback Points</span>
                </div>
            </div>
            <div class="stats" id="rawGrainsStats">Click "Generate Visualization" to see raw grain distribution...</div>
        </div>

        <!-- Grain Size Categories -->
        <div class="visualization-panel">
            <h3>Grain Size Categories</h3>
            <div class="layer-controls" id="sizeControls">
                <button class="layer-button active" onclick="showSizeCategory('all')">All Grains</button>
                <button class="layer-button" onclick="showSizeCategory('small')">Small</button>
                <button class="layer-button" onclick="showSizeCategory('medium')">Medium</button>
                <button class="layer-button" onclick="showSizeCategory('large')">Large</button>
            </div>
            <canvas id="sizeCategoriesCanvas" width="400" height="300"></canvas>
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background-color: #ff4400;"></div>
                    <span>Small Grains</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ff8800;"></div>
                    <span>Medium Grains</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ffff00;"></div>
                    <span>Large Grains</span>
                </div>
            </div>
            <div class="stats" id="sizeCategoriesStats">Click "Generate Visualization" to see size breakdown...</div>
        </div>

        <!-- Grain Sizes -->
        <div class="visualization-panel">
            <h3>Grain Size Distribution</h3>
            <canvas id="sizesCanvas" width="400" height="300"></canvas>
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background-color: #ffff00;"></div>
                    <span>Large Grains</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ff8800;"></div>
                    <span>Medium Grains</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ff4400;"></div>
                    <span>Small Grains</span>
                </div>
            </div>
            <div class="stats" id="sizesStats">Click "Generate Visualization" to see size distribution...</div>
        </div>

        <!-- Spatial Grid -->
        <div class="visualization-panel">
            <h3>Spatial Acceleration Grid</h3>
            <canvas id="gridCanvas" width="400" height="300"></canvas>
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background-color: #333333;"></div>
                    <span>Grid Lines</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #666666;"></div>
                    <span>Cell Boundaries</span>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background-color: #ffffff;"></div>
                    <span>Grains</span>
                </div>
            </div>
            <div class="stats" id="gridStats">Click "Generate Visualization" to see spatial grid...</div>
        </div>
    </div>

    <div id="devModeWarning" class="warning" style="display: none;">
        ‚ö†Ô∏è This debug page requires development mode. Build the project in production mode to hide this page.
    </div>

    <script type="module">
        // Check if we're in development mode
        const isDevelopment = import.meta.env?.DEV !== false; // Default to true for this debug page
        
        if (!isDevelopment) {
            document.getElementById('devModeWarning').style.display = 'block';
            document.body.style.opacity = '0.5';
        }

        // Import the actual GrainGenerator class to avoid code duplication
        import { GrainGenerator } from '../src/grain-generator.js';
        
        console.log('GrainGenerator imported for debug visualization:', GrainGenerator);
        
        // Global state for visualization
        let currentGrainStructure = null;
        let currentLayers = null;
        let currentRawGrains = null;
        let currentSettings = null;

        // Update intensity display
        document.getElementById('grainIntensity').addEventListener('input', function() {
            document.getElementById('intensityValue').textContent = this.value;
        });

        // Grain debug visualizer that uses the production GrainGenerator
        class GrainDebugVisualizer {
            constructor(width, height, settings) {
                this.width = width;
                this.height = height;
                this.settings = settings;
                this.grainGenerator = new GrainGenerator(width, height, settings);
            }
            
            // Analyze area coverage by checking how well grains cover the image
            analyzeCoverage(points, minDistance) {
                const gridSize = minDistance / 2; // Smaller grid for finer analysis
                const cols = Math.ceil(this.width / gridSize);
                const rows = Math.ceil(this.height / gridSize);
                let coveredCells = 0;
                
                // Check each grid cell to see if it's covered by a grain
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cellX = (col + 0.5) * gridSize;
                        const cellY = (row + 0.5) * gridSize;
                        
                        // Check if any grain covers this cell
                        for (const point of points) {
                            const distance = Math.sqrt((cellX - point.x) ** 2 + (cellY - point.y) ** 2);
                            if (distance <= minDistance) {
                                coveredCells++;
                                break; // Found coverage, move to next cell
                            }
                        }
                    }
                }
                
                const totalCells = rows * cols;
                return coveredCells / totalCells;
            }
            
            generateRawGrains() {
                const params = this.grainGenerator.calculateGrainParameters();
                
                console.log('=== Raw Grain Generation ===');
                console.log(`Image: ${this.width}x${this.height}`);
                console.log(`ISO: ${this.settings.iso}`);
                console.log(`Base size: ${params.baseGrainSize.toFixed(3)}`);
                console.log(`Density: ${params.grainDensity}`);
                console.log(`Min distance: ${params.minDistance.toFixed(3)}`);
                
                const poissonPoints = this.grainGenerator.generatePoissonDiskSampling(params.minDistance, params.grainDensity);
                
                let fallbackPoints = [];
                let finalPoints = poissonPoints;
                
                // Analyze coverage to determine if we need fallback grains
                const coverage = this.analyzeCoverage(poissonPoints, params.minDistance);
                const shouldUseFallback = poissonPoints.length < params.grainDensity * 0.85 || coverage < 0.75;
                
                if (shouldUseFallback) {
                    console.log(`Using fallback: points=${poissonPoints.length}/${params.grainDensity} (${(poissonPoints.length/params.grainDensity*100).toFixed(1)}%), coverage=${(coverage*100).toFixed(1)}%`);
                    finalPoints = this.grainGenerator.generateFallbackGrains(poissonPoints, params.grainDensity, params.minDistance);
                    fallbackPoints = finalPoints.slice(poissonPoints.length);
                }
                
                return {
                    poissonPoints,
                    fallbackPoints,
                    finalPoints,
                    params
                };
            }
            
            generateLayerStructure() {
                // Use new single-layer approach with variable grain sizes
                const grains = this.grainGenerator.generateGrainStructure();
                const params = this.grainGenerator.calculateGrainParameters();
                return [{
                    layerType: 'variable-size',
                    grains: grains,
                    baseSize: params.baseGrainSize,
                    density: grains.length,
                    intensityMultiplier: 1.0
                }];
            }
        }

        function log(message, statsElementId) {
            const element = document.getElementById(statsElementId);
            if (element) {
                element.textContent += message + '\n';
                element.scrollTop = element.scrollHeight;
            }
            console.log(message);
        }

        function clearStats(statsElementId) {
            const element = document.getElementById(statsElementId);
            if (element) {
                element.textContent = '';
            }
        }

        function drawPoints(canvasId, points, color = '#ffffff', size = 1) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Safety check for currentSettings
            if (!currentSettings) {
                console.error('currentSettings not available for point drawing');
                return;
            }
            
            // Calculate scaling factors
            const scaleX = canvas.width / currentSettings.width;
            const scaleY = canvas.height / currentSettings.height;
            
            ctx.fillStyle = color;
            for (const point of points) {
                // Scale position and size
                const scaledX = point.x * scaleX;
                const scaledY = point.y * scaleY;
                const scaledSize = Math.max(1, size * Math.min(scaleX, scaleY));
                
                // Draw as circle for better visibility
                ctx.beginPath();
                ctx.arc(scaledX, scaledY, scaledSize, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawGrains(canvasId, grains, color = '#ffffff') {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Safety check for currentSettings
            if (!currentSettings) {
                console.error('currentSettings not available for grain drawing');
                return;
            }
            
            // Calculate scaling factors
            const scaleX = canvas.width / currentSettings.width;
            const scaleY = canvas.height / currentSettings.height;
            
            // Add transparency to see overlapping grains
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = color;
            
            let drawnCount = 0;
            for (const grain of grains) {
                // Scale both position and size
                const scaledX = grain.x * scaleX;
                const scaledY = grain.y * scaleY;
                // Use minimum scale to maintain aspect ratio of grain size
                const scaledSize = Math.max(0.5, grain.size * Math.min(scaleX, scaleY));
                
                // Draw grain as a circle for better visualization
                ctx.beginPath();
                ctx.arc(scaledX, scaledY, scaledSize / 2, 0, 2 * Math.PI);
                ctx.fill();
                drawnCount++;
            }
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
            
            console.log(`Drew ${drawnCount} grains for ${canvasId} with color ${color}`);
        }

        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas with ID '${canvasId}' not found`);
                return;
            }
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function updateCanvasSize(canvasId, width, height) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas with ID '${canvasId}' not found`);
                return;
            }
            canvas.width = width;
            canvas.height = height;
        }

        function visualizeRawGrains(grainData) {
            clearStats('rawGrainsStats');
            clearCanvas('rawGrainsCanvas');
            
            // Calculate scaling factors for logging
            const canvas = document.getElementById('rawGrainsCanvas');
            const scaleX = canvas.width / currentSettings.width;
            const scaleY = canvas.height / currentSettings.height;
            
            // Draw a border around the canvas to show the image bounds
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
            
            // Draw grid lines to show coordinate system
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 10; x++) {
                const gridX = (x / 10) * canvas.width;
                ctx.beginPath();
                ctx.moveTo(gridX, 0);
                ctx.lineTo(gridX, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= 10; y++) {
                const gridY = (y / 10) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, gridY);
                ctx.lineTo(canvas.width, gridY);
                ctx.stroke();
            }
            
            // Draw Poisson points in green
            drawPoints('rawGrainsCanvas', grainData.poissonPoints, '#00ff00', 3);
            
            // Draw fallback points in red
            if (grainData.fallbackPoints.length > 0) {
                drawPoints('rawGrainsCanvas', grainData.fallbackPoints, '#ff6666', 3);
            }
            
            // Log statistics with scaling information
            log(`=== Image and Canvas Info ===`, 'rawGrainsStats');
            log(`Original image: ${currentSettings.width}x${currentSettings.height}`, 'rawGrainsStats');
            log(`Canvas size: ${canvas.width}x${canvas.height}`, 'rawGrainsStats');
            log(`Scale factors: X=${scaleX.toFixed(3)}, Y=${scaleY.toFixed(3)}`, 'rawGrainsStats');
            log(``, 'rawGrainsStats');
            log(`=== Grain Distribution ===`, 'rawGrainsStats');
            log(`Poisson points: ${grainData.poissonPoints.length}`, 'rawGrainsStats');
            log(`Fallback points: ${grainData.fallbackPoints.length}`, 'rawGrainsStats');
            log(`Total points: ${grainData.finalPoints.length}`, 'rawGrainsStats');
            log(`Target density: ${grainData.params.grainDensity}`, 'rawGrainsStats');
            log(`Achieved density: ${(grainData.finalPoints.length / (currentSettings.width * currentSettings.height) * 1000).toFixed(2)} per 1000px`, 'rawGrainsStats');
            log(`Base grain size: ${grainData.params.baseGrainSize.toFixed(3)}px`, 'rawGrainsStats');
            log(`Min distance: ${grainData.params.minDistance.toFixed(3)}px`, 'rawGrainsStats');
            
            // Add sample coordinates for debugging
            if (grainData.poissonPoints.length > 0) {
                log(``, 'rawGrainsStats');
                log(`=== Sample Poisson coordinates ===`, 'rawGrainsStats');
                const sampleCount = Math.min(5, grainData.poissonPoints.length);
                for (let i = 0; i < sampleCount; i++) {
                    const point = grainData.poissonPoints[i];
                    const scaledX = (point.x * scaleX).toFixed(1);
                    const scaledY = (point.y * scaleY).toFixed(1);
                    log(`Point ${i}: (${point.x.toFixed(1)}, ${point.y.toFixed(1)}) -> canvas (${scaledX}, ${scaledY})`, 'rawGrainsStats');
                }
            }
        }

        function visualizeSizeCategories(layers, activeCategory = 'all') {
            clearStats('sizeCategoriesStats');
            clearCanvas('sizeCategoriesCanvas');
            
            // Get all grains from the single layer
            const allGrains = layers.flatMap(layer => layer.grains);
            if (allGrains.length === 0) {
                log('No grains to categorize', 'sizeCategoriesStats');
                return;
            }
            
            // Calculate size thresholds
            const sizes = allGrains.map(g => g.size);
            const avgSize = sizes.reduce((sum, size) => sum + size, 0) / sizes.length;
            const smallThreshold = avgSize * 0.8;
            const largeThreshold = avgSize * 1.2;
            
            // Categorize grains by size
            const categories = {
                small: allGrains.filter(g => g.size < smallThreshold),
                medium: allGrains.filter(g => g.size >= smallThreshold && g.size <= largeThreshold),
                large: allGrains.filter(g => g.size > largeThreshold)
            };
            
            const categoryColors = {
                small: '#ff4400',
                medium: '#ff8800',
                large: '#ffff00'
            };
            
            let visibleGrains = 0;
            
            // Draw grains based on active category
            if (activeCategory === 'all') {
                // Draw all categories with their respective colors
                for (const [categoryName, grains] of Object.entries(categories)) {
                    drawGrains('sizeCategoriesCanvas', grains, categoryColors[categoryName]);
                    visibleGrains += grains.length;
                }
            } else if (categories[activeCategory]) {
                // Draw only the selected category
                drawGrains('sizeCategoriesCanvas', categories[activeCategory], categoryColors[activeCategory]);
                visibleGrains = categories[activeCategory].length;
            }
            
            // Display statistics
            log(`Size Categories (threshold: avg ¬± 20%)`, 'sizeCategoriesStats');
            log(`Average size: ${avgSize.toFixed(2)}px`, 'sizeCategoriesStats');
            log(``, 'sizeCategoriesStats');
            
            for (const [categoryName, grains] of Object.entries(categories)) {
                const percentage = ((grains.length / allGrains.length) * 100).toFixed(1);
                log(`${categoryName}: ${grains.length} grains (${percentage}%)`, 'sizeCategoriesStats');
                
                if (grains.length > 0) {
                    const categorySize = grains.map(g => g.size);
                    const minSize = Math.min(...categorySize);
                    const maxSize = Math.max(...categorySize);
                    const avgCategorySize = categorySize.reduce((a, b) => a + b, 0) / categorySize.length;
                    log(`  Size range: ${minSize.toFixed(2)} - ${maxSize.toFixed(2)}px`, 'sizeCategoriesStats');
                    log(`  Avg size: ${avgCategorySize.toFixed(2)}px`, 'sizeCategoriesStats');
                }
            }
            
            log(``, 'sizeCategoriesStats');
            log(`Total grains: ${allGrains.length}`, 'sizeCategoriesStats');
            log(`Visible grains (${activeCategory}): ${visibleGrains}`, 'sizeCategoriesStats');
        }
        
        // Function to handle size category selection
        window.showSizeCategory = function(category) {
            // Update button states
            document.querySelectorAll('#sizeControls .layer-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`#sizeControls .layer-button[onclick="showSizeCategory('${category}')"]`).classList.add('active');
            
            // Re-visualize with the selected category
            if (currentLayers) {
                visualizeSizeCategories(currentLayers, category);
            }
        };

        function visualizeSizeDistribution(layers) {
            clearStats('sizesStats');
            clearCanvas('sizesCanvas');
            
            const allGrains = layers.flatMap(layer => layer.grains);
            const sizes = allGrains.map(g => g.size);
            const minSize = Math.min(...sizes);
            const maxSize = Math.max(...sizes);
            const sizeRange = maxSize - minSize;
            
            // Categorize grains by size
            const smallThreshold = minSize + sizeRange * 0.33;
            const mediumThreshold = minSize + sizeRange * 0.66;
            
            const smallGrains = allGrains.filter(g => g.size <= smallThreshold);
            const mediumGrains = allGrains.filter(g => g.size > smallThreshold && g.size <= mediumThreshold);
            const largeGrains = allGrains.filter(g => g.size > mediumThreshold);
            
            // Draw with different colors
            drawGrains('sizesCanvas', smallGrains, '#ff4400');
            drawGrains('sizesCanvas', mediumGrains, '#ff8800');
            drawGrains('sizesCanvas', largeGrains, '#ffff00');
            
            // Log statistics
            log(`Size range: ${minSize.toFixed(2)} - ${maxSize.toFixed(2)}`, 'sizesStats');
            log(`Small grains (<${smallThreshold.toFixed(2)}): ${smallGrains.length}`, 'sizesStats');
            log(`Medium grains: ${mediumGrains.length}`, 'sizesStats');
            log(`Large grains (>${mediumThreshold.toFixed(2)}): ${largeGrains.length}`, 'sizesStats');
            log(`Average size: ${(sizes.reduce((a, b) => a + b, 0) / sizes.length).toFixed(2)}`, 'sizesStats');
        }

        function visualizeSpatialGrid(layers) {
            clearStats('gridStats');
            clearCanvas('gridCanvas');
            
            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate scaling factors
            const scaleX = canvas.width / currentSettings.width;
            const scaleY = canvas.height / currentSettings.height;
            
            const allGrains = layers.flatMap(layer => layer.grains);
            const maxGrainSize = Math.max(...allGrains.map(g => g.size));
            
            // Grid size should be based on original image space, then scaled
            const originalGridSize = Math.max(8, Math.floor(maxGrainSize * 2));
            const scaledGridSize = originalGridSize * Math.min(scaleX, scaleY);
            
            const gridCols = Math.ceil(currentSettings.width / originalGridSize);
            const gridRows = Math.ceil(currentSettings.height / originalGridSize);
            
            // Draw grid lines (scaled to canvas)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= gridCols; x++) {
                const scaledX = (x * originalGridSize) * scaleX;
                ctx.beginPath();
                ctx.moveTo(scaledX, 0);
                ctx.lineTo(scaledX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= gridRows; y++) {
                const scaledY = (y * originalGridSize) * scaleY;
                ctx.beginPath();
                ctx.moveTo(0, scaledY);
                ctx.lineTo(canvas.width, scaledY);
                ctx.stroke();
            }
            
            // Draw cell boundaries for cells with grains
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            
            const cellCounts = new Map();
            
            for (const grain of allGrains) {
                const cellX = Math.floor(grain.x / originalGridSize);
                const cellY = Math.floor(grain.y / originalGridSize);
                const cellKey = `${cellX},${cellY}`;
                cellCounts.set(cellKey, (cellCounts.get(cellKey) || 0) + 1);
            }
            
            for (const [cellKey, count] of cellCounts.entries()) {
                const [cellX, cellY] = cellKey.split(',').map(Number);
                const x = (cellX * originalGridSize) * scaleX;
                const y = (cellY * originalGridSize) * scaleY;
                const width = originalGridSize * scaleX;
                const height = originalGridSize * scaleY;
                
                ctx.strokeRect(x, y, width, height);
            }
            
            // Draw grains as white dots
            drawGrains('gridCanvas', allGrains, '#ffffff');
            
            // Log statistics
            log(`Original grid size: ${originalGridSize}px`, 'gridStats');
            log(`Scaled grid size: ${scaledGridSize.toFixed(1)}px`, 'gridStats');
            log(`Grid dimensions: ${gridCols} x ${gridRows}`, 'gridStats');
            log(`Total cells: ${gridCols * gridRows}`, 'gridStats');
            log(`Occupied cells: ${cellCounts.size}`, 'gridStats');
            log(`Occupancy rate: ${(cellCounts.size / (gridCols * gridRows) * 100).toFixed(1)}%`, 'gridStats');
            log(`Max grains in cell: ${Math.max(...cellCounts.values())}`, 'gridStats');
            log(`Avg grains per occupied cell: ${(allGrains.length / cellCounts.size).toFixed(1)}`, 'gridStats');
        }

        window.generateDebugVisualization = function() {
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const iso = parseInt(document.getElementById('iso').value);
            const filmType = document.getElementById('filmType').value;
            const grainIntensity = parseFloat(document.getElementById('grainIntensity').value);
            
            currentSettings = {
                width,
                height,
                iso,
                filmType,
                grainIntensity,
                upscaleFactor: 1.0
            };
            
            generateVisualizationWithSettings(currentSettings);
        };

        window.testGrainDensity = function() {
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const iso = parseInt(document.getElementById('iso').value);
            
            console.log('=== Testing Grain Density Calculation ===');
            console.log(`Image size: ${width}x${height} = ${width * height} pixels`);
            console.log(`ISO: ${iso}`);
            
            // Test density calculation manually
            const baseGrainSize = Math.max(0.5, iso / 200);
            const imageArea = width * height;
            const densityFactor = Math.min(0.05, iso / 10000);
            const grainDensity = Math.floor(imageArea * densityFactor);
            const minDistance = Math.max(1, baseGrainSize * 0.3);
            
            console.log(`Base grain size: ${baseGrainSize.toFixed(3)}`);
            console.log(`Density factor: ${densityFactor.toFixed(6)}`);
            console.log(`Target grain density: ${grainDensity}`);
            console.log(`Min distance: ${minDistance.toFixed(3)}`);
            
            // Test what happens with very simple settings
            const testSettings = {
                width,
                height,
                iso: 200, // Low ISO
                filmType: 'kodak',
                grainIntensity: 1.0,
                upscaleFactor: 1.0
            };
            
            const testVisualizer = new GrainDebugVisualizer(width, height, testSettings);
            const testParams = testVisualizer.grainGenerator.calculateGrainParameters();
            console.log('Calculated parameters:', testParams);
            
            // Test just the raw Poisson generation
            const poissonPoints = testVisualizer.grainGenerator.generatePoissonDiskSampling(testParams.minDistance, testParams.grainDensity);
            console.log(`Poisson generated: ${poissonPoints.length} / ${testParams.grainDensity} points`);
            
            // Test fallback generation
            const fallbackPoints = testVisualizer.grainGenerator.generateFallbackGrains([], testParams.grainDensity);
            console.log(`Fallback generated: ${fallbackPoints.length} points`);
        };

        function generateVisualizationWithSettings(settings) {
            // Use fixed canvas sizes for consistent visualization
            const canvasWidth = 400;
            const canvasHeight = 300;
            
            // Update all canvas sizes to fixed dimensions
            updateCanvasSize('rawGrainsCanvas', canvasWidth, canvasHeight);
            updateCanvasSize('sizeCategoriesCanvas', canvasWidth, canvasHeight);
            updateCanvasSize('sizesCanvas', canvasWidth, canvasHeight);
            updateCanvasSize('gridCanvas', canvasWidth, canvasHeight);
            
            clearAllCanvases();
            
            const visualizer = new GrainDebugVisualizer(settings.width, settings.height, settings);
            
            console.log('=== Debug Visualization Generation ===');
            console.log('Settings:', settings);
            
            // Generate raw grains
            currentRawGrains = visualizer.generateRawGrains();
            console.log('Raw grains generated:', currentRawGrains);
            visualizeRawGrains(currentRawGrains);
            
            // Generate grain structure
            currentLayers = visualizer.generateLayerStructure();
            console.log('Grain structure generated:', currentLayers);
            console.log('Grain counts:', currentLayers.map(l => ({ type: l.layerType, count: l.grains.length })));
            
            // Log some sample grains for debugging
            if (currentLayers.length > 0 && currentLayers[0].grains.length > 0) {
                console.log('Sample grains from structure:', currentLayers[0].grains.slice(0, 5));
            }
            
            visualizeSizeCategories(currentLayers);
            
            // Show size distribution
            visualizeSizeDistribution(currentLayers);
            
            // Show spatial grid
            visualizeSpatialGrid(currentLayers);
        }

        window.clearAllCanvases = function() {
            ['rawGrainsCanvas', 'sizeCategoriesCanvas', 'sizesCanvas', 'gridCanvas'].forEach(clearCanvas);
            ['rawGrainsStats', 'sizeCategoriesStats', 'sizesStats', 'gridStats'].forEach(clearStats);
        };

        // Generate initial visualization on load
        window.onload = function() {
            try {
                console.log('Debug page loaded, testing GrainGenerator...');
                window.generateDebugVisualization();
            } catch (error) {
                console.error('Error during debug initialization:', error);
            }
        };
    </script>
</body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grain Patterns Test Visualization</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #1a1a1a;
        color: #ffffff;
      }

      .dev-only {
        border: 2px solid #ff6b35;
        padding: 15px;
        margin-bottom: 20px;
        background-color: #2a1a1a;
        border-radius: 8px;
      }

      .dev-only h2 {
        color: #ff6b35;
        margin-top: 0;
      }

      .controls {
        margin: 20px 0;
        padding: 15px;
        background-color: #2a2a2a;
        border-radius: 5px;
      }

      .controls label {
        display: inline-block;
        width: 140px;
        margin-right: 10px;
        font-weight: bold;
      }

      .controls input,
      .controls select {
        margin: 5px 10px 5px 0;
        padding: 4px 8px;
        background-color: #3a3a3a;
        color: #ffffff;
        border: 1px solid #555;
        border-radius: 3px;
      }

      .visualization-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .visualization-panel {
        background-color: #2a2a2a;
        border-radius: 8px;
        padding: 15px;
      }

      .visualization-panel h3 {
        color: #ff6b35;
        margin-top: 0;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }

      canvas {
        border: 1px solid #444;
        margin: 10px 0;
        background-color: #000;
        max-width: 100%;
        height: auto;
      }

      button {
        background-color: #ff6b35;
        color: white;
        border: none;
        padding: 8px 16px;
        margin: 5px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      button:hover {
        background-color: #e55a2e;
      }

      button:disabled {
        background-color: #666;
        cursor: not-allowed;
      }

      .stats {
        background-color: #333;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        white-space: pre-wrap;
      }

      .warning {
        background-color: #8b4513;
        border: 1px solid #ff6b35;
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        color: #ffcc99;
      }

      .grain-grid-overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        opacity: 0.7;
      }

      .canvas-container {
        position: relative;
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <div class="dev-only">
      <h2>ðŸ§ª Grain Patterns Test Visualization</h2>
      <p>
        This page replicates the test case:
        <code
          >"should produce uniform output with uniform dense grid grains without
          anisotropic effects"</code
        >
      </p>
      <p>
        The test creates a uniform 4-pixel spaced grid of grains with identical
        properties and verifies that the output shows no directional bias
        (stripes).
      </p>
    </div>

    <div class="controls">
      <div>
        <label>Grid Spacing:</label>
        <input type="range" id="grainSpacing" min="2" max="8" value="4" />
        <span id="grainSpacingValue">4</span> pixels
      </div>
      <div>
        <label>Grain Size:</label>
        <input
          type="range"
          id="grainSize"
          min="1"
          max="5"
          step="0.1"
          value="2.0"
        />
        <span id="grainSizeValue">2.0</span>
      </div>
      <div>
        <label>Sensitivity:</label>
        <input
          type="range"
          id="grainSensitivity"
          min="0.1"
          max="1.0"
          step="0.05"
          value="0.5"
        />
        <span id="grainSensitivityValue">0.5</span>
      </div>
      <div>
        <label>Threshold:</label>
        <input
          type="range"
          id="grainThreshold"
          min="0.05"
          max="0.5"
          step="0.05"
          value="0.1"
        />
        <span id="grainThresholdValue">0.1</span>
      </div>
      <div>
        <label>Density:</label>
        <input
          type="range"
          id="grainDensity"
          min="0.1"
          max="1.0"
          step="0.05"
          value="0.5"
        />
        <span id="grainDensityValue">0.5</span>
      </div>
      <div>
        <label>ISO:</label>
        <input type="range" id="iso" min="50" max="400" step="50" value="100" />
        <span id="isoValue">100</span>
      </div>
      <div>
        <button onclick="generatePattern()">Generate Pattern</button>
        <button onclick="runAnalysis()">Run Anisotropy Analysis</button>
      </div>
    </div>

    <div class="visualization-grid">
      <div class="visualization-panel">
        <h3>Grain Grid Layout</h3>
        <div class="canvas-container">
          <canvas id="grainGridCanvas" width="256" height="256"></canvas>
        </div>
        <div class="stats" id="grainGridStats">
          Click "Generate Pattern" to see grain placement...
        </div>
      </div>

      <div class="visualization-panel">
        <h3>Processed Output</h3>
        <div class="canvas-container">
          <canvas id="processedCanvas" width="256" height="256"></canvas>
        </div>
        <div class="stats" id="processedStats">
          Processed image will appear here...
        </div>
      </div>

      <div class="visualization-panel">
        <h3>Uniformity Analysis</h3>
        <canvas id="histogramCanvas" width="256" height="128"></canvas>
        <div class="stats" id="uniformityStats">
          Statistical analysis will appear here...
        </div>
      </div>

      <div class="visualization-panel">
        <h3>Anisotropy Test</h3>
        <canvas id="anisotropyCanvas" width="256" height="128"></canvas>
        <div class="stats" id="anisotropyStats">
          Directional bias analysis will appear here...
        </div>
      </div>
    </div>

    <div class="warning">
      <strong>Note:</strong> This is a simplified visualization that replicates
      the test logic. It may not use the exact same grain processing algorithm
      as the production code.
    </div>

    <script type="module">
      // Import the necessary modules
      import { GrainProcessor } from '../src/grain-processor.js';
      import { SpatialLookupGrid } from '../src/spatial-lookup-grid.js';

      // Global state
      let currentGrains = [];
      let currentResult = null;
      let currentSettings = null;

      // Create test settings function (matching the test)
      function createTestSettings(iso) {
        return {
          iso,
          filmType: 'kodak',
        };
      }

      // Create grain intrinsic density function (matching the test)
      function createGrainIntrinsicDensity(density) {
        return density;
      }

      // Testable GrainProcessor class (matching the test)
      class TestableGrainProcessor extends GrainProcessor {
        testProcessPixelEffects(
          grainGrid,
          grainIntrinsicDensityMap,
          outputWidth,
          outputHeight
        ) {
          return this.processPixelEffects(
            grainGrid,
            grainIntrinsicDensityMap,
            outputWidth,
            outputHeight
          );
        }
      }

      // Analysis functions (copied from test)
      function analyzeHorizontalVariations(data, width, height) {
        let totalVariation = 0;
        let comparisons = 0;

        for (let y = 0; y < height - 1; y++) {
          for (let x = 0; x < width; x++) {
            const currentPixel = data[(y * width + x) * 4]; // R channel
            const nextPixel = data[((y + 1) * width + x) * 4];
            totalVariation += Math.abs(currentPixel - nextPixel);
            comparisons++;
          }
        }

        return comparisons > 0 ? totalVariation / comparisons : 0;
      }

      function analyzeVerticalVariations(data, width, height) {
        let totalVariation = 0;
        let comparisons = 0;

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width - 1; x++) {
            const currentPixel = data[(y * width + x) * 4]; // R channel
            const nextPixel = data[(y * width + (x + 1)) * 4];
            totalVariation += Math.abs(currentPixel - nextPixel);
            comparisons++;
          }
        }

        return comparisons > 0 ? totalVariation / comparisons : 0;
      }

      // Update display values
      function updateDisplayValues() {
        document.getElementById('grainSpacingValue').textContent =
          document.getElementById('grainSpacing').value;
        document.getElementById('grainSizeValue').textContent =
          document.getElementById('grainSize').value;
        document.getElementById('grainSensitivityValue').textContent =
          document.getElementById('grainSensitivity').value;
        document.getElementById('grainThresholdValue').textContent =
          document.getElementById('grainThreshold').value;
        document.getElementById('grainDensityValue').textContent =
          document.getElementById('grainDensity').value;
        document.getElementById('isoValue').textContent =
          document.getElementById('iso').value;
      }

      // Generate grain pattern
      window.generatePattern = function () {
        const width = 64;
        const height = 64;
        const grainSpacing = parseInt(
          document.getElementById('grainSpacing').value
        );
        const grainSize = parseFloat(
          document.getElementById('grainSize').value
        );
        const grainSensitivity = parseFloat(
          document.getElementById('grainSensitivity').value
        );
        const grainThreshold = parseFloat(
          document.getElementById('grainThreshold').value
        );
        const grainDensity = parseFloat(
          document.getElementById('grainDensity').value
        );
        const iso = parseInt(document.getElementById('iso').value);

        // Create uniform grains on a grid (matching the test)
        const uniformGrains = [];
        for (let y = grainSpacing; y < height; y += grainSpacing) {
          for (let x = grainSpacing; x < width; x += grainSpacing) {
            uniformGrains.push({
              x,
              y,
              size: grainSize,
              sensitivity: grainSensitivity,
              developmentThreshold: grainThreshold,
            });
          }
        }

        currentGrains = uniformGrains;
        currentSettings = createTestSettings(iso);

        // Visualize grain grid
        visualizeGrainGrid(uniformGrains, width, height);

        // Create spatial lookup grid
        const grainGrid = new SpatialLookupGrid(width, height, uniformGrains);

        // Create uniform grain density map
        const grainIntrinsicDensityMap = new Map();
        for (const grain of uniformGrains) {
          grainIntrinsicDensityMap.set(
            grain,
            createGrainIntrinsicDensity(grainDensity)
          );
        }

        // Process with testable grain processor
        try {
          const processor = new TestableGrainProcessor(
            width,
            height,
            currentSettings
          );
          currentResult = processor.testProcessPixelEffects(
            grainGrid,
            grainIntrinsicDensityMap,
            width,
            height
          );

          // Visualize processed result
          visualizeProcessedResult(currentResult, width, height);

          // Update stats
          updateGrainGridStats(uniformGrains, width, height, grainSpacing);
          updateProcessedStats(currentResult);
        } catch (error) {
          console.error('Error processing grains:', error);
          document.getElementById('processedStats').textContent =
            `Error: ${error.message}`;
        }
      };

      // Run anisotropy analysis
      window.runAnalysis = function () {
        if (!currentResult) {
          alert('Please generate a pattern first');
          return;
        }

        const width = 64;
        const height = 64;
        const outputData = currentResult.resultFloatData;

        // Collect pixel values
        const pixelValues = [];
        for (let i = 0; i < outputData.length; i += 4) {
          pixelValues.push(outputData[i]);
        }

        // Calculate statistics
        const mean =
          pixelValues.reduce((sum, val) => sum + val, 0) / pixelValues.length;
        const variance =
          pixelValues.reduce((sum, val) => sum + (val - mean) ** 2, 0) /
          pixelValues.length;
        const stdDev = Math.sqrt(variance);

        let minValue = pixelValues[0];
        let maxValue = pixelValues[0];
        for (let i = 1; i < pixelValues.length; i++) {
          if (pixelValues[i] < minValue) minValue = pixelValues[i];
          if (pixelValues[i] > maxValue) maxValue = pixelValues[i];
        }

        // Anisotropy analysis
        const horizontalVariations = analyzeHorizontalVariations(
          outputData,
          width,
          height
        );
        const verticalVariations = analyzeVerticalVariations(
          outputData,
          width,
          height
        );
        const anisotropyRatio =
          Math.max(horizontalVariations, verticalVariations) /
          Math.min(horizontalVariations, verticalVariations);

        // Update displays
        updateUniformityAnalysis(pixelValues, mean, stdDev, minValue, maxValue);
        updateAnisotropyAnalysis(
          horizontalVariations,
          verticalVariations,
          anisotropyRatio
        );

        // Test results
        const uniformityPass = stdDev < 0.2;
        const anisotropyPass = anisotropyRatio < 2.0;

        const testResults = `
TEST RESULTS:
Uniformity Test: ${uniformityPass ? 'PASS' : 'FAIL'} (StdDev: ${stdDev.toFixed(4)} < 0.2)
Anisotropy Test: ${anisotropyPass ? 'PASS' : 'FAIL'} (Ratio: ${anisotropyRatio.toFixed(4)} < 2.0)

Overall: ${uniformityPass && anisotropyPass ? 'PASS' : 'FAIL'}
        `;

        document.getElementById('anisotropyStats').textContent = testResults;
      };

      // Visualization functions
      function visualizeGrainGrid(grains, width, height) {
        const canvas = document.getElementById('grainGridCanvas');
        const ctx = canvas.getContext('2d');
        const scale = canvas.width / width;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let x = 0; x <= width; x += 4) {
          ctx.beginPath();
          ctx.moveTo(x * scale, 0);
          ctx.lineTo(x * scale, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= height; y += 4) {
          ctx.beginPath();
          ctx.moveTo(0, y * scale);
          ctx.lineTo(canvas.width, y * scale);
          ctx.stroke();
        }

        // Draw grains
        ctx.fillStyle = '#ff6b35';
        for (const grain of grains) {
          const x = grain.x * scale;
          const y = grain.y * scale;
          const size = grain.size * scale;
          ctx.fillRect(x - size / 2, y - size / 2, size, size);
        }
      }

      function visualizeProcessedResult(result, width, height) {
        const canvas = document.getElementById('processedCanvas');
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const scale = canvas.width / width;

        // Scale up the result data
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const srcX = Math.floor(x / scale);
            const srcY = Math.floor(y / scale);
            const srcIndex = (srcY * width + srcX) * 4;
            const dstIndex = (y * canvas.width + x) * 4;

            const value = Math.floor(result.resultFloatData[srcIndex] * 255);
            imageData.data[dstIndex] = value; // R
            imageData.data[dstIndex + 1] = value; // G
            imageData.data[dstIndex + 2] = value; // B
            imageData.data[dstIndex + 3] = 255; // A
          }
        }

        ctx.putImageData(imageData, 0, 0);
      }

      function updateGrainGridStats(grains, width, height, spacing) {
        const stats = `
Grain Count: ${grains.length}
Image Size: ${width} Ã— ${height}
Grid Spacing: ${spacing} pixels
Expected Grains: ${Math.floor(width / spacing) * Math.floor(height / spacing)}
Coverage: ${((grains.length / (width * height)) * 100).toFixed(2)}%
        `;
        document.getElementById('grainGridStats').textContent = stats;
      }

      function updateProcessedStats(result) {
        const stats = `
Grain Effects: ${result.grainEffectCount}
Processed Pixels: ${result.processedPixels}
Processing Rate: ${((result.grainEffectCount / result.processedPixels) * 100).toFixed(2)}%
        `;
        document.getElementById('processedStats').textContent = stats;
      }

      function updateUniformityAnalysis(
        pixelValues,
        mean,
        stdDev,
        minValue,
        maxValue
      ) {
        // Draw histogram
        const canvas = document.getElementById('histogramCanvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Create histogram
        const bins = 32;
        const histogram = new Array(bins).fill(0);
        const range = maxValue - minValue;

        for (const value of pixelValues) {
          const bin = Math.min(
            bins - 1,
            Math.floor(((value - minValue) / range) * bins)
          );
          histogram[bin]++;
        }

        const maxCount = Math.max(...histogram);
        const binWidth = canvas.width / bins;

        ctx.fillStyle = '#ff6b35';
        for (let i = 0; i < bins; i++) {
          const height = (histogram[i] / maxCount) * canvas.height;
          ctx.fillRect(
            i * binWidth,
            canvas.height - height,
            binWidth - 1,
            height
          );
        }

        // Update stats
        const stats = `
Mean: ${mean.toFixed(4)}
Std Dev: ${stdDev.toFixed(4)}
Min: ${minValue.toFixed(4)}
Max: ${maxValue.toFixed(4)}
Range: ${range.toFixed(4)}
        `;
        document.getElementById('uniformityStats').textContent = stats;
      }

      function updateAnisotropyAnalysis(horizontal, vertical, ratio) {
        // Draw directional variations
        const canvas = document.getElementById('anisotropyCanvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const maxVariation = Math.max(horizontal, vertical);
        const hHeight = (horizontal / maxVariation) * canvas.height * 0.8;
        const vHeight = (vertical / maxVariation) * canvas.height * 0.8;

        ctx.fillStyle = '#ff6b35';
        ctx.fillRect(
          canvas.width * 0.2,
          canvas.height - hHeight,
          canvas.width * 0.3,
          hHeight
        );

        ctx.fillStyle = '#35a7ff';
        ctx.fillRect(
          canvas.width * 0.6,
          canvas.height - vHeight,
          canvas.width * 0.3,
          vHeight
        );

        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.fillText('H', canvas.width * 0.3, canvas.height - 5);
        ctx.fillText('V', canvas.width * 0.7, canvas.height - 5);
      }

      // Set up event listeners
      document
        .getElementById('grainSpacing')
        .addEventListener('input', updateDisplayValues);
      document
        .getElementById('grainSize')
        .addEventListener('input', updateDisplayValues);
      document
        .getElementById('grainSensitivity')
        .addEventListener('input', updateDisplayValues);
      document
        .getElementById('grainThreshold')
        .addEventListener('input', updateDisplayValues);
      document
        .getElementById('grainDensity')
        .addEventListener('input', updateDisplayValues);
      document
        .getElementById('iso')
        .addEventListener('input', updateDisplayValues);

      // Initialize
      updateDisplayValues();
      generatePattern();
    </script>
  </body>
</html>
